# -*- coding: utf-8 -*-
"""LSTM model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V_B7EkxHXkW91rG8Jz0LELGg4EB75ryq
"""

import tensorflow as tf

gpus = tf.config.list_physical_devices("GPU")

if gpus:
  tf.config.experimental.set_memory_growth(gpus[0], True)
  tf.config.set_visible_devices([gpus[0]],"GPU")

import pandas as pd
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt

plt.rcParams['axes.unicode_minus'] = False

from numpy import array
from sklearn import metrics
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM, Bidirectional

from numpy.random import seed
seed(1)
tf.random.set_seed(1)

n_timestamp = 40
n_epochs = 30

model_type =1

from google.colab import files
data = files.upload()

data = pd.read_csv('bitcoin_price.csv')
print(data.head())

data.shape

training_set = data.iloc[0:1556- 400, 2:3].values 
test_set = data.iloc[1556-400:, 2:3].values

sc = MinMaxScaler(feature_range= (0,1))
training_set_scaled = sc.fit_transform(training_set)
testing_set_scaled = sc.transform(test_set)

def data_split(sequence,n_timestamp):
   X = []
   y= []
   for i in range(len(sequence)):
     end_ix = i + n_timestamp

     if end_ix > len(sequence)-1:
       break
      
     seq_x, seq_y = sequence[i:end_ix], sequence[end_ix]
     X.append(seq_x)
     y.append(seq_y)
   return array(X), array(y)

X_train, y_train = data_split (training_set_scaled, n_timestamp)

X_train = X_train.reshape(X_train.shape[0], X_train.shape[1],1)

X_test,y_test = data_split(testing_set_scaled,n_timestamp)
X_test = X_test.reshape(X_test.shape[0],X_test.shape[1],1)

if model_type == 1:
  model = Sequential()
  model.add (LSTM(units=50, activation='relu',
             input_shape = (X_train.shape[1],1)))
  model.add(Dense(units=1))

if model_type == 2:
  model = Sequential()
  model.add(LSTM(units=50, activation='relu', return_sequences = True,
                 input_shape=(X_train.shape[1],1)))
  model.add(LSTM(units=50, activation='relu'))
  model.add(Dense(1))

if model_type == 3:
  model = Sequential()
  model.add(Bidirectional(LSTM(50, activation='relu'),
                          input_shape=(X_train.shape[1],1)))
  model.add(Dense(1))

model.summary()

model.compile(optimizer=tf.keras.optimizers.Adam(0.001),
              loss='mean_squared_error')

history = model.fit(X_train, y_train,
                    batch_size =64,
                    epochs=n_epochs,
                    validation_data= (X_test, y_test),
                    validation_freq=1)

model.summary()

plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Training and Validation Loss')
plt.legend()
plt.show()

predicted_bitcoin_price = model.predict(X_test)
predicted_bitcoin_price = sc.inverse_transform(predicted_bitcoin_price)
real_bitcoin_price = sc.inverse_transform(y_test)

plt.plot(real_bitcoin_price, color='orange', label='Bitcoin Price')
plt.plot(predicted_bitcoin_price, color='blue', label='Predicted Bitcoin Price')
plt.title('Bitcoin Price Prediction')
plt.xlabel('Time')
plt.ylabel('Bitcoin Price')
plt.legend()
plt.show()

MSE = metrics.mean_squared_error( real_bitcoin_price,predicted_bitcoin_price)
RMSE = metrics.mean_squared_error( real_bitcoin_price,predicted_bitcoin_price)**0.5
MAE = metrics.mean_absolute_error( real_bitcoin_price,predicted_bitcoin_price)
R2 = metrics.r2_score( real_bitcoin_price,predicted_bitcoin_price)

print('Mean Square Error: %.5f'% MSE)
print('Root Mean Square Error : %.5f' % RMSE)
print('Mean Absolute Error : %.5f' % MAE)
print('R-Squared : %.5f'% R2)